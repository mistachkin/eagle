###############################################################################
#
# file3.eagle --
#
# Extensible Adaptable Generalized Logic Engine (Eagle)
# Eagle File 3 Package File
#
# Copyright (c) 2007-2012 by Joe Mistachkin.  All rights reserved.
#
# See the file "license.terms" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: $
#
###############################################################################

#
# NOTE: Use our own namespace here because even though we do not directly
#       support namespaces ourselves, we do not want to pollute the global
#       namespace if this script actually ends up being evaluated in Tcl.
#
namespace eval ::Eagle {
  #
  # NOTE: This procedure attempts to emit a Tcl log message based on the
  #       calling procedure currently being invoked.  This procedure is
  #       explicitly designed to allow overriding via external scripts.
  #
  proc tclLogForCommand { {command ""} } {
    set level [info level]; # current procedure
    set procName [lindex [info level $level] 0]
    incr level -1; # calling procedure

    if {[string length $command] > 0} then {
      set equals [string repeat = $level]

      set suffix [appendArgs \
          " " $equals "> command \{" $command \}]

      if {[uplevel 1 [list info exists error]]} then {
        set error [uplevel 1 [list set error]]

        if {[string length $error] > 0} then {
          append suffix " " $equals "> error \{" $error \}
        }
      } elseif {[uplevel 1 [list info exists result]]} then {
        set result [uplevel 1 [list set result]]

        if {[string length $result] > 0} then {
          append suffix " " $equals "> result \{" $result \}
        }
      }
    } else {
      set suffix ""
    }

    catch {
      tclLog [string trim [appendArgs \
          $procName " (level " [format %03d $level] ") " \
          [string repeat - $level] "> \{" [info level \
          $level] \} $suffix]]
    }
  }

  #
  # NOTE: This procedure figures out extra option values for use with the
  #       "dir" command of the Windows command shell based on which types
  #       of paths are being saught.  This procedure is not explicitly
  #       designed to allow overriding via external scripts; however, it
  #       can be overridden if some care is taken to maintain compatible
  #       semantics.
  #
  proc populateTypesForComSpecDir { dirVarName fileVarName } {
    upvar 1 $dirVarName dirTypes
    upvar 1 $fileVarName fileTypes

    set dirTypes(visible) {/ad}
    set dirTypes(hidden) {/ahd}

    set fileTypes(visible) {/a-d}
    set fileTypes(hidden) {/ah-d}
  }

  #
  # NOTE: This procedure figures out what the -types option values should
  #       be to locate both visible and hidden directories and/or files.
  #       This procedure is not explicitly designed to allow overriding
  #       via external scripts; however, it can be overridden if some care
  #       is taken to maintain compatible semantics.
  #
  proc populateTypesForGlob { dirVarName fileVarName } {
    upvar 1 $dirVarName dirTypes
    upvar 1 $fileVarName fileTypes

    set dirTypes(visible) {d}
    set fileTypes(visible) {f}

    if {[isEagle]} then {
      #
      # HACK: Using "hiddenonly" requires release Beta 51 or later.
      #
      set dirTypes(hidden) {d system hidden hiddenonly}
      set fileTypes(hidden) {f system hidden hiddenonly}
    } else {
      set dirTypes(hidden) {d hidden}
      set fileTypes(hidden) {f hidden}
    }
  }

  #
  # NOTE: This procedure returns a list of paths (presumably from [glob])
  #       that have been filtered to remove those that are unwanted, e.g.
  #       the "." and ".." directories, etc.  This procedure is explicitly
  #       designed to allow overriding via external scripts.
  #
  proc filterForGlob { paths } {
    set result [list]

    foreach path $paths {
      #
      # HACK: The "in" operator for [expr] cannot be used here if we want
      #       to support Tcl 8.4.
      #
      if {[lsearch -exact [list . ..] $path] != -1} then {
        continue
      }

      lappend result $path
    }

    return $result
  }

  #
  # NOTE: This procedure returns non-zero if file and directory searches
  #       are able to use the "dir" command of the Windows command shell.
  #       This procedure is not explicitly designed to allow overriding
  #       via external scripts; however, it can be overridden if some
  #       care is taken to maintain compatible semantics.
  #
  proc canUseComSpecDir { pattern } {
    if {[info exists ::no(canUseComSpecDir)]} then {
      return false
    }

    if {![isWindows]} then {
      return false
    }

    if {![info exists ::env(ComSpec)]} then {
      return false
    }

    return true
  }

  #
  # NOTE: This procedure returns the current directory value that should be
  #       used when converting relative paths to absolute paths from within
  #       the [getDirResultPath] procedure.  This procedure is explicitly
  #       designed to allow overriding via external scripts.
  #
  proc pwdForDirResultPath { pattern path } {
    return [pwd]
  }

  #
  # NOTE: This procedure uses the type of the specified path to figure out
  #       the (possibly normalized) path to add to the finder results.
  #       This procedure is not explicitly designed to allow overriding via
  #       external scripts; however, it can be overridden if some care is
  #       taken to maintain compatible semantics.
  #
  proc getDirResultPath { pattern path } {
    if {[file pathtype $path] eq "absolute"} then {
      return [file normalize $path]
    } else {
      #
      # BUGBUG: There is not much we can do here that would be correct in
      #         all situations.  The problem is that the Windows command
      #         shell "dir" command does not return enough relative path
      #         information when invoked without the sub-directories flag.
      #
      if {[hasRuntimeOption getDirResultJoinPath]} then {
        if {![isEagle] || \
            [string is path -strict $pattern] || \
            [string is component -strict $pattern]} then {
          if {[file pathtype $pattern] eq "absolute"} then {
            set newPath [file normalize $pattern]
          } else {
            set newPath [file normalize [file join \
                [pwdForDirResultPath $pattern $path] $pattern]]
          }

          if {![file exists $newPath]} then {
            set newPath [file normalize [file join $newPath $path]]
          }
        } else {
          set newPath [file normalize [file join \
              [pwdForDirResultPath $pattern $path] $path]]
        }

        if {[file exists $newPath]} then {
          return $newPath
        }
      }

      if {[hasRuntimeOption getDirResultErrorPath]} then {
        error [appendArgs \
            "could not handle relative path \"" $path \
            "\" resulting from pattern \"" $pattern \"]
      }

      return $path
    }
  }

  #
  # NOTE: This procedure attempts to normalize the specified path in a way
  #       that (ideally) should not raise a script error.  This procedure
  #       is explicitly designed to allow overriding via external scripts.
  #
  proc fileNormalizeForGlob { path } {
    if {[isEagle]} then {
      #
      # HACK: Possibly disable the legacy path resolution to avoid raising
      #       any script errors.
      #
      # TODO: This is (probably) not quite robust enough to handle all of
      #       the possible corner cases.
      #
      if {[string is path -strict $path] || \
          [string is component -strict $path]} then {
        return [file normalize -legacy true $path]
      } else {
        return [file normalize -legacy false $path]
      }
    } else {
      #
      # BUGBUG: Can this really not raise a script error in Tcl?
      #
      return [file normalize $path]
    }
  }

  #
  # NOTE: This procedure performs [glob] using specified types, directory,
  #       and pattern.  This procedure is not explicitly designed to allow
  #       overriding via external scripts; however, it can be overridden
  #       if some care is taken to maintain compatible semantics.
  #
  proc performGlob { types directory pattern } {
    if {[hasRuntimeOption tracePerformGlob]} then {
      tclLogForCommand
    }

    return [filterForGlob [glob -nocomplain -types \
        $types [fileNormalizeForGlob [file join $directory \
        $pattern]]]]
  }

  #
  # NOTE: This procedure works around the lack of the -nocase option to the
  #       native Tcl interpreter for versions before 8.5.  It should not be
  #       used by external callers.  This procedure is not explicitly
  #       designed to allow overriding via external scripts; however, it
  #       can be overridden if some care is taken to maintain compatible
  #       semantics.
  #
  proc maybeAppendPathResult { listVarName element } {
    upvar 1 $listVarName list

    if {[isEagle]} then {
      if {[lsearch -variable -exact -nocase list $element] == -1} then {
        lappend list $element
      }
    } else {
      if {[info exists ::tcl_version] && $::tcl_version >= 8.5} then {
        if {![info exists list] || \
            [lsearch -exact -nocase $list $element] == -1} then {
          lappend list $element
        }
      } else {
        if {![info exists list] || [lsearch -exact [string \
            tolower $list] [string tolower $element]] == -1} then {
          lappend list $element
        }
      }
    }

    return ""
  }

  #
  # NOTE: This procedure attempts to find files and directories within a
  #       specific parent directory.  It can optionally use recursion to
  #       traverse into sub-directories matching a specific pattern.  It
  #       can find visible items, hidden items, or both.  To find both,
  #       an empty string should be passed for the "hidden" argument.
  #
  proc findViaGlob {
          directory traversePattern wantPattern wantDirs wantFiles hidden
          recursive allowEmpty allowFiltered {callback ""} } {
    set result [list]

    if {($allowEmpty || [string length $wantPattern] > 0) && \
        ($allowFiltered || [llength [filterForGlob [list \
        $wantPattern]]] > 0)} then {
      populateTypesForGlob dirTypes fileTypes

      foreach type [list visible hidden] {
        set wantHidden [expr {
          $type eq "hidden" ? "true" : "false"
        }]

        if {[string length $hidden] == 0 || \
            [string is $wantHidden -strict $hidden]} then {
          if {$recursive && \
              [string length $traversePattern] > 0 && \
              [info exists dirTypes($type)]} then {
            if {[catch {
              performGlob $dirTypes($type) $directory \
                  $traversePattern
            } list] == 0} then {
              foreach subDirectory $list {
                eval lappend result [findViaGlob \
                    $subDirectory $traversePattern \
                    $wantPattern $wantDirs $wantFiles \
                    $hidden $recursive $allowEmpty \
                    $allowFiltered $callback]
              }
            }
          }

          if {[string length $wantPattern] > 0} then {
            if {$wantDirs && \
                [info exists dirTypes($type)]} then {
              if {[catch {
                performGlob $dirTypes($type) $directory \
                    $wantPattern
              } list] == 0} then {
                if {[string length $callback] == 0} then {
                  eval lappend result $list
                } else {
                  foreach element $list {
                    if {[$callback $callback \
                        $type directory $element]} then {
                      lappend result $element
                    }
                  }
                }
              }
            }

            if {$wantFiles && \
                [info exists fileTypes($type)]} then {
              if {[catch {
                performGlob $fileTypes($type) $directory \
                    $wantPattern
              } list] == 0} then {
                if {[string length $callback] == 0} then {
                  eval lappend result $list
                } else {
                  foreach element $list {
                    if {[$callback $callback \
                        $type file $element]} then {
                      lappend result $element
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return $result
  }

  #
  # NOTE: This procedure attempts to find files and directories within a
  #       specific parent directory.  It can optionally use recursion to
  #       traverse into sub-directories matching a specific pattern.  It
  #       can find visible items, hidden items, or both.  To find both,
  #       an empty string should be passed for the "hidden" argument.
  #
  proc findViaComSpecDir {
          directory pattern wantDirs wantFiles hidden recursive
          allowEmpty allowFiltered } {
    set result [list]

    if {[canUseComSpecDir $pattern] && ($allowEmpty || [string length \
        $pattern] > 0) && ($allowFiltered || [llength [filterForGlob \
        [list $pattern]]] > 0)} then {
      set path ""

      if {[isEagle]} then {
        makeVariableFast result true; makeVariableFast path true
      }

      set types [list]

      if {[string length $hidden] > 0} then {
        if {[string is false -strict $hidden]} then {
          lappend types visible
        }

        if {[string is true -strict $hidden]} then {
          lappend types hidden
        }
      } else {
        lappend types visible hidden
      }

      set subTypes [list]

      if {$wantDirs} then {lappend subTypes directory}
      if {$wantFiles} then {lappend subTypes file}

      populateTypesForComSpecDir dirTypes fileTypes

      foreach type $types {
        foreach subType $subTypes {
          set wantVarName [expr {
            $subType eq "directory" ? \
                [appendArgs dirTypes( $type )] : \
                [appendArgs fileTypes( $type )]
          }]

          if {[info exists $wantVarName]} then {
            set command [list exec]

            if {[isEagle]} then {lappend command -unicode}

            lappend command $::env(ComSpec)
            if {[isEagle]} then {lappend command /u}
            lappend command /c

            if {[string length $directory] > 0 && \
                [lsearch -exact [list . ..] $directory] == -1} then {
              lappend command cd

              if {[isEagle]} then {
                lappend command [appendArgs \
                    \" [file nativename $directory] \"]
              } else {
                lappend command [file nativename $directory]
              }

              lappend command &&
            }

            lappend command dir /b
            if {$recursive} then {lappend command /s}
            lappend command [set $wantVarName]

            if {[string length $pattern] > 0} then {
              if {[isEagle]} then {
                lappend command [appendArgs \
                    \" [file nativename $pattern] \"]
              } else {
                lappend command [file nativename $pattern]
              }
            }

            if {[hasRuntimeOption traceFindViaComSpecDir]} then {
              tclLogForCommand $command
            }

            if {[catch $command exec] == 0} then {
              foreach path [split $exec \n] {
                set path [string trim $path]

                if {[string length $path] > 0} then {
                  set path [getDirResultPath $pattern $path]
                  maybeAppendPathResult result $path
                }
              }
            }
          }
        }
      }
    }

    return $result
  }

  #
  # NOTE: This procedure may return directory name information that may be
  #       present in the specified pattern.  If the directory name does not
  #       represent an absolute path, an empty string is returned instead.
  #       This procedure is explicitly designed to allow overriding via
  #       external scripts.
  #
  proc fileDirNameForFind { pattern } {
    set result [file dirname $pattern]

    if {[string length $result] > 0 && \
        [file pathtype $result] eq "absolute"} then {
      return $result
    }

    return ""
  }

  #
  # NOTE: This procedure returns the file name portion that may be present
  #       in the specified pattern.  This procedure is explicitly designed
  #       to allow overriding via external scripts.
  #
  proc fileTailForFind { pattern } {
    if {[string length $pattern] > 0 && \
        [file pathtype $pattern] eq "absolute"} then {
      return [file tail $pattern]
    }

    return $pattern
  }

  #
  # NOTE: This procedure returns a list of directories matching the pattern
  #       specified.  It does not recurse into sub-directories.
  #
  proc findDirectories { pattern } {
    if {![info exists ::no(findForEagle)] && \
        ![info exists ::no(findDirectoriesForEagle)] && \
        [isEagle]} then {
      if {![canUseComSpecDir $pattern] || \
          [hasRuntimeOption findViaGlob]} then {
        return [findViaGlob \
            [fileDirNameForFind $pattern] * \
            [fileTailForFind $pattern] \
            true false "" false false false]
      } else {
        return [findViaComSpecDir \
            [fileDirNameForFind $pattern] \
            $pattern true false "" false \
            false false]
      }
    } else {
      if {[canUseComSpecDir $pattern] && \
          [hasRuntimeOption findViaComSpecDir]} then {
        return [findViaComSpecDir \
            [fileDirNameForFind $pattern] \
            $pattern true false "" false \
            false false]
      } else {
        populateTypesForGlob dirTypes fileTypes

        set result [list]

        eval lappend result [filterForGlob [glob -nocomplain \
            -types $dirTypes(visible) [fileNormalizeForGlob \
            $pattern]]]

        eval lappend result [filterForGlob [glob -nocomplain \
            -types $dirTypes(hidden) [fileNormalizeForGlob \
            $pattern]]]

        return $result
      }
    }
  }

  #
  # NOTE: This procedure returns a list of directories matching the pattern
  #       specified.  It recurses into sub-directories.
  #
  proc findDirectoriesRecursive { pattern } {
    if {![canUseComSpecDir $pattern] || \
        [hasRuntimeOption findViaGlob]} then {
      return [findViaGlob \
          [fileDirNameForFind $pattern] * \
          [fileTailForFind $pattern] \
          true false "" true false false]
    } else {
      return [findViaComSpecDir \
          [fileDirNameForFind $pattern] \
          $pattern true false "" true \
          false false]
    }
  }

  #
  # NOTE: This procedure returns a list of files matching the pattern
  #       specified.  It does not recurse into sub-directories.
  #
  proc findFiles { pattern } {
    if {![info exists ::no(findForEagle)] && \
        ![info exists ::no(findFilesForEagle)] && \
        [isEagle]} then {
      if {![canUseComSpecDir $pattern] || \
          [hasRuntimeOption findViaGlob]} then {
        return [findViaGlob \
            [fileDirNameForFind $pattern] * \
            [fileTailForFind $pattern] false \
            true "" false false false]
      } else {
        return [findViaComSpecDir \
            [fileDirNameForFind $pattern] \
            $pattern false true "" false \
            false false]
      }
    } else {
      if {[canUseComSpecDir $pattern] && \
          [hasRuntimeOption findViaComSpecDir]} then {
        return [findViaComSpecDir \
            [fileDirNameForFind $pattern] \
            $pattern false true "" false \
            false false]
      } else {
        populateTypesForGlob dirTypes fileTypes

        set result [list]

        eval lappend result [filterForGlob [glob -nocomplain \
            -types $fileTypes(visible) [fileNormalizeForGlob \
            $pattern]]]

        eval lappend result [filterForGlob [glob -nocomplain \
            -types $fileTypes(hidden) [fileNormalizeForGlob \
            $pattern]]]

        return $result
      }
    }
  }

  #
  # NOTE: This procedure returns a list of files matching the pattern
  #       specified.  It recurses into sub-directories.
  #
  proc findFilesRecursive { pattern } {
    if {![canUseComSpecDir $pattern] || \
        [hasRuntimeOption findViaGlob]} then {
      return [findViaGlob \
          [fileDirNameForFind $pattern] * \
          [fileTailForFind $pattern] false \
          true "" true false false]
    } else {
      return [findViaComSpecDir \
          [fileDirNameForFind $pattern] \
          $pattern false true "" true \
          false false]
    }
  }

  #
  # NOTE: This procedure attempts to copy all files matching the specified
  #       source directory and patterns to the destination directory.  This
  #       procedure may raise script errors.
  #
  proc copyFilesRecursive {
          sourceDirectory targetDirectory {patterns ""} {options ""} } {
    #
    # NOTE: Block non-Windows platforms since this is Windows specific.
    #
    if {![isWindows]} then {
      error "not supported on this operating system"
    }

    #
    # NOTE: Start out with the [exec] command and the necessary options
    #       to the command.
    #
    if {[isEagle]} then {
      set command [list exec -exitcode exitCode -- robocopy]
    } else {
      set command [list exec -- robocopy]
    }

    #
    # NOTE: Add the source and target directory names.  These are always
    #       required.
    #
    if {[isEagle]} then {
      lappend command [appendArgs \" [file nativename $sourceDirectory] \"]
      lappend command [appendArgs \" [file nativename $targetDirectory] \"]
    } else {
      lappend command [file nativename $sourceDirectory]
      lappend command [file nativename $targetDirectory]
    }

    #
    # NOTE: If there are patterns specified, add them now.  By default,
    #       all files are copied (i.e. "*.*").
    #
    if {[llength $patterns] > 0} then {
      eval lappend command $patterns
    }

    #
    # NOTE: Should the default Robocopy options be excluded?  Generally,
    #       these options should not be excluded.  All matching files
    #       are copied, using restartable mode, and using extra options
    #       when running as administrator to enable copying more files
    #       and metadata, e.g. using backup mode and copying the extra
    #       file security information.
    #
    if {[lsearch -exact $options -nocopyopts] == -1} then {
      lappend command /E

      if {[isEagle] && [isAdministrator]} then {
        lappend command /ZB /COPYALL
      } else {
        lappend command /Z
      }

      lappend command /DCOPY:T
    }

    #
    # NOTE: Should we override the default number of retries per file?
    #       If no retry related option is found, the Robocopy default
    #       behavior will be used (i.e. 1 million retries per file).
    #
    if {[set index [lsearch -glob $options -retries:*]] != -1} then {
      #
      # NOTE: Grab the retry option name/value from the list of options
      #       and attempt to extract the integer number of retries from
      #       it.
      #
      set value [lindex $options $index]

      if {[regexp -- {^-retries:(\d+)$} $value dummy retries] && \
          [string is integer -strict $retries] && $retries >= 0} then {
        #
        # NOTE: Use the specified number of retries.  This value will
        #       be greater than or equal to zero and within the range
        #       of a 32-bit integer.
        #
        lappend command [appendArgs /R: $retries]
      } else {
        #
        # NOTE: The specified number of retries is somehow invalid.
        #
        error "number of retries must be a positive integer"
      }
    } elseif {[lsearch -exact $options -retry] == -1} then {
      #
      # NOTE: Fallback to setting retry count to zero, which is used
      #       to disable per-file retries.
      #
      lappend command /R:0
    }

    #
    # NOTE: By default, do not process file system junctions.  This
    #       is used to avoid the possibility of infinite loops when
    #       traversing the file system (i.e. because it is trivial
    #       to utilize file system junctions in order to construct
    #       directory trees that loop back upon themselves).
    #
    if {[lsearch -exact $options -junctions] == -1} then {
      lappend command /XJ
    }

    #
    # NOTE: By default, do not purge any files that happen to be in
    #       the target directory.
    #
    if {[lsearch -exact $options -purge] != -1} then {
      lappend command /PURGE
    }

    #
    # NOTE: By default, do not produce a verbose log files in the
    #       temporary directory.
    #
    if {[lsearch -exact $options -logging] != -1} then {
      lappend command /X /V /FP /NP

      package require Eagle.Test
      set logFileName [getTemporaryFileName]

      if {[isEagle]} then {
        lappend command [appendArgs \
            \"/LOG: [file nativename $logFileName] \"]
      } else {
        lappend command [appendArgs \
            /LOG: [file nativename $logFileName]]
      }
    }

    #
    # NOTE: Optionally emit trace to log all our command arguments.
    #
    if {[hasRuntimeOption traceCopyFilesRecursive]} then {
      tclLogForCommand $command
    }

    #
    # NOTE: Upon success, the exit code from Robocopy will be between
    #       zero and seven.  If the exit code is eight or greater, it
    #       has somehow failed and that error must be reported to the
    #       caller via raising a script error.
    #
    if {[isEagle]} then {
      #
      # NOTE: Execute the resulting [exec] command in our context and
      #       capture the results.
      #
      set result [eval $command]

      if {[info exists exitCode] && $exitCode in \
          [list Success Failure Exception 0 1 2 3 4 5 6 7]} then {
        #
        # NOTE: Return the captured output from the Robocopy command,
        #       whatever it was.  Generally, this will either be the
        #       summary and details of the files copied -OR- the log
        #       file name.
        #
        return $result
      } else {
        #
        # NOTE: Raise a script error, using the captured errors from
        #       the Robocopy command, whatever it was.
        #
        error [appendArgs \
            "command \"" $command "\" error: " $result]
      }
    } else {
      #
      # NOTE: Execute the resulting [exec] command in our context and
      #       capture the results.
      #
      if {[catch $command result] == 0 || ([info exists ::errorCode] && \
          [maybeGetExitCode $::errorCode 8] < 8)} then {
        #
        # NOTE: Return the captured output from the Robocopy command,
        #       whatever it was.  Generally, this will either be the
        #       summary and details of the files copied -OR- the log
        #       file name.
        #
        return $result
      } else {
        #
        # NOTE: Raise a script error, using the captured errors from
        #       the Robocopy command, whatever it was.
        #
        error [appendArgs \
            "command \"" $command "\" error: " $result]
      }
    }
  }

  #
  # NOTE: Provide the Eagle "file finder" package to the interpreter.
  #
  package provide Eagle.File.Finder \
    [expr {[isEagle] ? [info engine PatchLevel] : "1.0"}]
}
